// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "ACILAssistant.h"
#include <fstream>
#include <sys/stat.h>
#include "PaintBrushAndEraserGUI.h"
#include "PaletteCounterGUI.h"
#include "QueryOverlayGUI.h"
#include "RegionGrowingGUI.h"
#include "ACILAssistantBase.h"
#include "itkImageFileReader.h"
#include "itkImageRegionIteratorWithIndex.h"
#include "itkImageSeriesReader.h"
#include "itkGDCMImageIO.h"
#include "itkGDCMSeriesFileNames.h"
#include "itkColorTable.h"
#include "itkImageFileWriter.h"
#include "cipChestConventions.h"
#include "itkImage.h"
#include <FL/Fl_File_Chooser.H>
#include <iostream>
#include <unistd.h>
using namespace std;

struct SESSIONDATA
{
  std::string patientID;
  std::string study;
  std::string caseName;
  std::string ctFileName;
  std::string ctFileNameHeader;
  std::string ctTmpDirAndFileNameHeader;
  std::string inLabelMapFileNameHeader;
  std::string inLabelMapTmpDirAndFileNameHeader;
  std::string outLabelMapFileNameHeader;
  std::string outLabelMapTmpDirAndFileNameHeader;
  std::string regionTypeIndicesFileName;
  std::string regionTypeIndicesTmpDirAndFileName;
  std::string studyTmpDir;
  std::string patientTmpDir;
  std::string caseTmpDir;
};

static std::vector< std::string > sessionGrayscaleFileNameVec;
static std::vector< std::string > sessionInLabelMapFileNameVec;
static std::vector< std::string > sessionOutLabelMapFileNameVec;
static std::vector< std::string > sessionRegionTypeIndicesFileNameVec;
static std::vector< SESSIONDATA > sessionDataVec;
static bool grayscaleImageRead = false;
static PaintBrushAndEraserGUI* paintBrushAndEraserInput;
static RegionGrowingGUI* regionGrowingInput;
static QueryOverlayGUI* queryOverlayInput;
static bool labelMapImageRead = false;
static ACILAssistantBase* assistantInstance;
static PaletteCounterGUI* paletteCounter;

std::string exec(const char*);
bool DoesRemoteFileExist(std::string study, std::string patientID, std::string caseName, std::string fileName);
void CopySessionDataFromMAD( SESSIONDATA data );
void CopySessionDataToMAD( SESSIONDATA data );

Fl_Double_Window *acilAssistantMainWindow=(Fl_Double_Window *)0;

Fl_Menu_Item menu_Menu[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Grayscale Image", 0,  (Fl_Callback*)GrayscaleImage_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dicom Directory", 0,  (Fl_Callback*)DicomDirectory_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Label Map Image", 0,  (Fl_Callback*)LabelMapImage_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Session File", 0,  (Fl_Callback*)SessionFile_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Save Session Data", 0,  (Fl_Callback*)SaveSessionDataMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Label Map Image", 0,  (Fl_Callback*)SaveLabelMapImageMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Region Type Points", 0,  (Fl_Callback*)SaveRegionTypePointsMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0,  (Fl_Callback*)Quit_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Tools", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Paint Brush And Eraser", 0,  (Fl_Callback*)paintBrushAndEraserMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Query Overlay", 0,  (Fl_Callback*)queryOverlayMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Segmentation", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Left Lung Right Lung", 0,  (Fl_Callback*)leftLungRightLungMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Lung Lobes", 0,  (Fl_Callback*)lungLobesMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Region Growing", 0,  (Fl_Callback*)regionGrowingMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Window-Level", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Lung", 0,  (Fl_Callback*)lungMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Muscle", 0,  (Fl_Callback*)muscleMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"View", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Palette Counter", 0,  (Fl_Callback*)paletteCounter_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {0,0,0,0,0,0,0,0,0}
};

itk::GLSliceView< short, unsigned short > *sliceViewer=(itk::GLSliceView< short, unsigned short > *)0;
Fl_Scrollbar *sliceSlider=(Fl_Scrollbar *)0;
Fl_Slider *opacitySlider=(Fl_Slider *)0;


int main(int argc, char **argv) {
  Fl_Double_Window* w;
  assistantInstance = new ACILAssistantBase();
  paletteCounter = new PaletteCounterGUI();
  regionGrowingInput = new RegionGrowingGUI();
  queryOverlayInput = new QueryOverlayGUI();

  paintBrushAndEraserInput = new PaintBrushAndEraserGUI();
  paintBrushAndEraserInput->SetUpdateViewerFunction( &UpdateViewer );
  paintBrushAndEraserInput->SetPaintedIndices( assistantInstance->GetPaintedIndices() );
  { Fl_Double_Window* o = acilAssistantMainWindow = new Fl_Double_Window(640, 630, "ACIL Assistant"); 
    w = o;
    o->color((Fl_Color)185);
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 830, 20, "Menu Bar");
      o->menu(menu_Menu);
    }
    { itk::GLSliceView< short, unsigned short >* o = sliceViewer = new itk::GLSliceView< short, unsigned short >(0, 20, 620, 590, "label");
      o->box(FL_NO_BOX);
      o->color((Fl_Color)48);
      o->selection_color((Fl_Color)48);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)48);
      o->align(FL_ALIGN_CENTER);
      o->when(FL_WHEN_RELEASE);
      sliceViewer->clickSelectCallBack( clickSelect_CB );
    }
    { Fl_Scrollbar* o = sliceSlider = new Fl_Scrollbar(620, 20, 20, 610);
      o->callback((Fl_Callback*)sliceSlider_CB);
      sliceSlider->linesize(1);
    }
    { Fl_Slider* o = opacitySlider = new Fl_Slider(0, 610, 620, 20);
      o->type(1);
      o->value(1);
      o->callback((Fl_Callback*)opacitySlider_CB);
    }
    o->end();
    o->resizable(o);
  }
  Fl::scheme("plastic");
  w->show(argc, argv);
  return Fl::run();
}

void GrayscaleImage_CB( Fl_Widget*, void* ) {
  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
    chooser.show();
 
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
  typedef itk::ImageFileReader< GrayscaleImageType >  ReaderType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Reading grayscale image..." << std::endl;
    ReaderType::Pointer reader = ReaderType::New();
      reader->SetFileName( chooser.value() );
      try
      {
        reader->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      	std::cerr << "Exception caught reading grayscale image:";
      	std::cerr << excp << std::endl;
      }
   
    ACILAssistantBase::GrayscaleImageType::SizeType     size;
    ACILAssistantBase::GrayscaleImageType::SpacingType  spacing;
    ACILAssistantBase::GrayscaleImageType::PointType    origin;
   
    size    = reader->GetOutput()->GetBufferedRegion().GetSize();
    spacing = reader->GetOutput()->GetSpacing();
    origin  = reader->GetOutput()->GetOrigin();
   
    assistantInstance->SetGrayscaleImage( reader->GetOutput() );	
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    int numberOfSlices = reader->GetOutput()->GetBufferedRegion().GetSize()[2];
 
    sliceSlider->maximum( numberOfSlices-1 );

 
    //-------
    // Label the main window to indicate which image has been read
    //
    std::string dirAndFileNameString( chooser.value() );
    
    unsigned int slashLoc = -1;
    
    do
      {
        slashLoc = dirAndFileNameString.find( "/", slashLoc+1 );
      }
    while ( dirAndFileNameString.find( "/", slashLoc+1 ) != std::string::npos );
     
    acilAssistantMainWindow->label( dirAndFileNameString.substr( slashLoc+1, dirAndFileNameString.size()-slashLoc-1 ).c_str() );
    
    std::cout << "DONE." << std::endl;
    
    grayscaleImageRead = true;
    }

  InitializeViewer();
}

void UpdateViewer() {
  sliceViewer->OverlayOpacity( opacitySlider->value() );	
sliceViewer->update();
sliceViewer->redraw();
sliceViewer->show();
sliceViewer->flush();
}

void DicomDirectory_CB( Fl_Widget*, void* ) {
  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::DIRECTORY, "Open");	                
    chooser.show();

typedef itk::Image< short, 3 >                        GrayscaleImageType;
typedef itk::GDCMImageIO                              ImageIOType;
typedef itk::GDCMSeriesFileNames                      NamesGeneratorType;
typedef itk::ImageSeriesReader< GrayscaleImageType >  SeriesReaderType;


//-------
// Block until user picks something
//
while(chooser.shown())
  {
  Fl::wait(); 
  }

if ( chooser.value() == NULL )
  {   
  return; 
  }
else
  {
  ImageIOType::Pointer gdcmImageIO = ImageIOType::New();
  
  NamesGeneratorType::Pointer namesGenerator = NamesGeneratorType::New();
    namesGenerator->SetInputDirectory( chooser.value() );

  const SeriesReaderType::FileNamesContainer & fileNames = namesGenerator->GetInputFileNames();

  std::cout << "Reading dicom directory..." << std::endl;
  SeriesReaderType::Pointer reader = SeriesReaderType::New();
    reader->SetFileNames( fileNames );
    reader->SetImageIO( gdcmImageIO );
  try
    {
    reader->Update();
    }
  catch ( itk::ExceptionObject &excp )
    {
    std::cerr << "Exception caught while reading dicom frame:";
    std::cerr << excp << std::endl;
    }    
    
    ACILAssistantBase::GrayscaleImageType::SizeType     size;
    ACILAssistantBase::GrayscaleImageType::SpacingType  spacing;
    ACILAssistantBase::GrayscaleImageType::PointType    origin;
   
    size    = reader->GetOutput()->GetBufferedRegion().GetSize();
    spacing = reader->GetOutput()->GetSpacing();
    origin  = reader->GetOutput()->GetOrigin();
   
    assistantInstance->SetGrayscaleImage( reader->GetOutput() );	
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    int numberOfSlices = reader->GetOutput()->GetBufferedRegion().GetSize()[2];
 
    sliceSlider->maximum( numberOfSlices-1 );
    
    std::cout << "DONE." << std::endl;
    
    grayscaleImageRead = true;

  }

InitializeViewer();
}

void InitializeViewer() {
  cip::ChestConventions conventions;

  //unsigned short obliqueFissureLabel         = conventions.GetValueFromLungRegionAndType( UNDEFINEDREGION, OBLIQUEFISSURE );
  //unsigned short horizontalFissureLabel      = conventions.GetValueFromLungRegionAndType( UNDEFINEDREGION, HORIZONTALFISSURE );
  //unsigned short leftLungLabel               = conventions.GetValueFromLungRegionAndType( LEFTLUNG, UNDEFINEDTYPE );
  //unsigned short rightLungLabel              = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, UNDEFINEDTYPE );
  //unsigned short leftObliqueFissureLabel     = conventions.GetValueFromLungRegionAndType( LEFTLUNG, OBLIQUEFISSURE );
  //unsigned short rightObliqueFissureLabel    = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, OBLIQUEFISSURE );
  //unsigned short rightHorizontalFissureLabel = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, HORIZONTALFISSURE );
  //unsigned short rightSuperiorLobeLabel      = conventions.GetValueFromLungRegionAndType( RIGHTSUPERIORLOBE, UNDEFINEDTYPE );
  //unsigned short rightMiddleLobeLabel        = conventions.GetValueFromLungRegionAndType( RIGHTMIDDLELOBE, UNDEFINEDTYPE );
  //unsigned short rightInferiorLobeLabel      = conventions.GetValueFromLungRegionAndType( RIGHTINFERIORLOBE, UNDEFINEDTYPE );
  //unsigned short leftSuperiorLobeLabel       = conventions.GetValueFromLungRegionAndType( LEFTSUPERIORLOBE, UNDEFINEDTYPE );
  //unsigned short leftInteriorLobeLabel       = conventions.GetValueFromLungRegionAndType( LEFTINFERIORLOBE, UNDEFINEDTYPE );

  //unsigned short airwayGeneration0Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION0 );
  //unsigned short airwayGeneration1Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION1 );
  //unsigned short airwayGeneration2Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION2 );
  unsigned short airwayGeneration3Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION3 );
  unsigned short airwayGeneration4Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION4 );
  unsigned short airwayGeneration5Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION5 );
  unsigned short airwayGeneration6Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION6 );
  unsigned short airwayGeneration7Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION7 );
  unsigned short airwayGeneration8Label  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::AIRWAYGENERATION8 );
  unsigned short expiratoryMalaciaLabel  = conventions.GetValueFromChestRegionAndType( cip::UNDEFINEDREGION, cip::EXPIRATORYMALACIA );

  unsigned short rulBronch = conventions.GetValueFromChestRegionAndType( cip::RIGHTSUPERIORLOBE, cip::BRONCHIECTATICAIRWAY );
  unsigned short rulNon    = conventions.GetValueFromChestRegionAndType( cip::RIGHTSUPERIORLOBE, cip::NONBRONCHIECTATICAIRWAY );
  unsigned short rulAm     = conventions.GetValueFromChestRegionAndType( cip::RIGHTSUPERIORLOBE, cip::AMBIGUOUSBRONCHIECTATICAIRWAY );

  unsigned short rmlBronch = conventions.GetValueFromChestRegionAndType( cip::RIGHTMIDDLELOBE, cip::BRONCHIECTATICAIRWAY );
  unsigned short rmlNon    = conventions.GetValueFromChestRegionAndType( cip::RIGHTMIDDLELOBE, cip::NONBRONCHIECTATICAIRWAY );
  unsigned short rmlAm     = conventions.GetValueFromChestRegionAndType( cip::RIGHTMIDDLELOBE, cip::AMBIGUOUSBRONCHIECTATICAIRWAY );

  unsigned short rllBronch = conventions.GetValueFromChestRegionAndType( cip::RIGHTINFERIORLOBE, cip::BRONCHIECTATICAIRWAY );
  unsigned short rllNon    = conventions.GetValueFromChestRegionAndType( cip::RIGHTINFERIORLOBE, cip::NONBRONCHIECTATICAIRWAY );
  unsigned short rllAm     = conventions.GetValueFromChestRegionAndType( cip::RIGHTINFERIORLOBE, cip::AMBIGUOUSBRONCHIECTATICAIRWAY );

  unsigned short lulBronch = conventions.GetValueFromChestRegionAndType( cip::LEFTSUPERIORLOBE, cip::BRONCHIECTATICAIRWAY );
  unsigned short lulNon    = conventions.GetValueFromChestRegionAndType( cip::LEFTSUPERIORLOBE, cip::NONBRONCHIECTATICAIRWAY );
  unsigned short lulAm     = conventions.GetValueFromChestRegionAndType( cip::LEFTSUPERIORLOBE, cip::AMBIGUOUSBRONCHIECTATICAIRWAY );

  unsigned short lllBronch = conventions.GetValueFromChestRegionAndType( cip::LEFTINFERIORLOBE, cip::BRONCHIECTATICAIRWAY );
  unsigned short lllNon    = conventions.GetValueFromChestRegionAndType( cip::LEFTINFERIORLOBE, cip::NONBRONCHIECTATICAIRWAY );
  unsigned short lllAm     = conventions.GetValueFromChestRegionAndType( cip::LEFTINFERIORLOBE, cip::AMBIGUOUSBRONCHIECTATICAIRWAY );          
  
  typedef itk::ColorTable< float > ColorTableType;

  ColorTableType::Pointer colorTable = ColorTableType::New();
  colorTable->UseRandomColors( 50000 );

  //colorTable->SetColor( obliqueFissureLabel-1,         0.0, 0.0, 0.5, "ObliqueFissure" );
  //colorTable->SetColor( horizontalFissureLabel-1,      0.0, 0.0, 1.0, "HorizontalFissure" );
  //colorTable->SetColor( leftLungLabel-1,               0.0, 1.0, 0.0, "LeftLung" );
  //colorTable->SetColor( rightLungLabel-1,              0.0, 1.0, 1.0, "RightLung" );
  //colorTable->SetColor( leftObliqueFissureLabel-1,     1.0, 0.0, 0.0, "LeftObliqueFissure" );
  //colorTable->SetColor( rightObliqueFissureLabel-1,    1.0, 0.0, 1.0, "RightObliqueFissure" );
  //colorTable->SetColor( rightHorizontalFissureLabel-1, 1.0, 1.0, 0.0, "RightHorizontalFissure" );
  //colorTable->SetColor( rightSuperiorLobeLabel-1,      0.5, 0.5, 0.0, "RightSuperiorLobe" );
  //colorTable->SetColor( rightMiddleLobeLabel-1,        0.0, 0.5, 0.5, "RightMiddleLobe" );
  //colorTable->SetColor( rightInferiorLobeLabel-1,      0.0, 0.5, 0.0, "RightInferiorLobe" );
  //colorTable->SetColor( leftSuperiorLobeLabel-1,       0.5, 0.0, 0.5, "LeftSuperiorLobe" );
  //colorTable->SetColor( leftInteriorLobeLabel-1,       0.5, 0.0, 0.0, "LeftInteriorLobe" );
  //colorTable->SetColor( expiratoryMalaciaLabel-1,       0.0, 1.0, 0.0, "ExpiratoryMalacia" );

  // colorTable->SetColor( airwayGeneration3Label-1, 0.63, 0.13, 0.94, "AirwayGeneration3" );
  // colorTable->SetColor( airwayGeneration4Label-1, 0.0,  1.0,  0.0,  "AirwayGeneration4" );
  // colorTable->SetColor( airwayGeneration5Label-1, 1.0,  0.41, 0.71, "AirwayGeneration5" );
  // colorTable->SetColor( airwayGeneration6Label-1, 0.39, 0.58, 0.93, "AirwayGeneration6" );
  // colorTable->SetColor( airwayGeneration7Label-1, 1.0,  1.0,  0.0,  "AirwayGeneration7" );
  // colorTable->SetColor( airwayGeneration8Label-1, 1.0,  0.0,  0.0,  "AirwayGeneration8" );

  colorTable->SetColor( rulBronch-1, 1.0,  0.0,  0.0,  "rulBronch" );
  colorTable->SetColor( rulNon-1,    1.0,  0.0,  0.0,  "rulNon" );
  colorTable->SetColor( rulAm-1,     1.0,  0.0,  0.0,  "rulAm" );

  colorTable->SetColor( rmlBronch-1, 0.0,  1.0,  0.0,  "rmlBronch" );
  colorTable->SetColor( rmlNon-1,    0.0,  1.0,  0.0,  "rmlNon" );
  colorTable->SetColor( rmlAm-1,     0.0,  1.0,  0.0,  "rmlAm" );

  colorTable->SetColor( rllBronch-1, 0.6,  0.8,  1.0,  "rllBronch" );
  colorTable->SetColor( rllNon-1,    0.6,  0.8,  1.0,  "rllNon" );
  colorTable->SetColor( rllAm-1,     0.6,  0.8,  1.0,  "rllAm" );

  colorTable->SetColor( lulBronch-1, 1.0,  1.0,  0.0,  "lulBronch" );
  colorTable->SetColor( lulNon-1,    1.0,  1.0,  0.0,  "lulNon" );
  colorTable->SetColor( lulAm-1,     1.0,  1.0,  0.0,  "lulAm" );

  colorTable->SetColor( lllBronch-1, 1.0,  0.6,  0.8,  "lllBronch" );
  colorTable->SetColor( lllNon-1,    1.0,  0.6,  0.8,  "lllNon" );
  colorTable->SetColor( lllAm-1,     1.0,  0.6,  0.8,  "lllAm" );

  sliceViewer->clear();
  sliceViewer->SetInputImage( assistantInstance->GetGrayscaleImage() );
  sliceViewer->SetInputOverlay( assistantInstance->GetLabelMapImage() );
  sliceViewer->orientation( 2 );
  sliceViewer->flipY( true );
  sliceViewer->sliceNum( 0 );
  sliceViewer->iwMax( -100 );
  sliceViewer->iwMin( -1200 );
  sliceViewer->SetOverlayColorIndex( 50000 );
  sliceViewer->SetColorTable( colorTable );

  paintBrushAndEraserInput->SetLabelMapImage( assistantInstance->GetLabelMapImage() );

  UpdateViewer();
}

void sliceSlider_CB( Fl_Widget*, void* ) {
  sliceViewer->sliceNum( sliceSlider->value() );

UpdateViewer();
}

void LabelMapImage_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
    {
  std::cerr << "Must first read a grayscale image!" << std::endl;
  
  return;
}


Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
    chooser.show();
 
  typedef itk::Image< unsigned short, 3 >       LabelMapType;
  typedef itk::ImageFileReader< LabelMapType >  ReaderType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Reading label map image..." << std::endl;
    ReaderType::Pointer reader = ReaderType::New();
      reader->SetFileName( chooser.value() );
      try
      {
        reader->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      	std::cerr << "Exception caught reading grayscale image:";
      	std::cerr << excp << std::endl;
      }
   
    assistantInstance->SetLabelMapImage( reader->GetOutput() );	
    
    sliceViewer->SetInputOverlay( assistantInstance->GetLabelMapImage() );    
    
    labelMapImageRead = true;
        
    UpdateViewer();    
        
    std::cout << "DONE." << std::endl;
    }
}

void SessionFile_CB( Fl_Widget*, void* ) {
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
  typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType; 
  typedef itk::Image< unsigned short, 3 >             LabelMapType;
  typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType; 

  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
  chooser.show();
 
  // Block until user picks something
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    char firstLine[512];
    char secondLine[512];
    char thirdLine[512];
    char fourthLine[512];
    
    std::cout << "Reading session file..." << std::endl;    
    std::ifstream sessionFile( chooser.value() );
    while ( !sessionFile.eof() )
      {
      sessionFile.getline( firstLine, 512 );
      std::string grayscaleEntry( firstLine );   
    
      sessionFile.getline( secondLine, 512 ); 
      std::string inLabelMapEntry( secondLine );        
    
      sessionFile.getline( thirdLine, 512 );
      std::string outLabelMapEntry( thirdLine );   
    
      sessionFile.getline( fourthLine, 512 );  
      std::string regionTypeIndicesEntry( fourthLine );

      if (grayscaleEntry.length() > 0)
        {
        // Begin by parsing all the component strings that we'll need to
        // copy data, check for file existince, etc.
        std::string patientID;
        std::string study;
        std::string caseName;
        std::string ctFileName;
        std::string ctFileNameHeader;
        std::string ctTmpDirAndFileNameHeader;
        std::string inLabelMapFileNameHeader;
        std::string inLabelMapTmpDirAndFileNameHeader;
        std::string outLabelMapFileNameHeader;
        std::string outLabelMapTmpDirAndFileNameHeader;
        std::string regionTypeIndicesFileName;
        std::string regionTypeIndicesTmpDirAndFileName;
        std::string studyTmpDir;
        std::string patientTmpDir;
        std::string caseTmpDir;

        int patientIDStart = grayscaleEntry.find( '/', 0 );  
        int patientIDStop  = grayscaleEntry.find( '/', patientIDStart + 1);
        patientID = grayscaleEntry.substr( patientIDStart+1, patientIDStop - patientIDStart - 1);
        
	int firstSlash  = grayscaleEntry.find( '/' );  
	int secondSlash = grayscaleEntry.find( '/', firstSlash + 1 );  
        int thirdSlash  = grayscaleEntry.find_last_of('/');
        caseName = grayscaleEntry.substr( secondSlash + 1, thirdSlash - secondSlash - 1);
        study = grayscaleEntry.substr(0, patientIDStart);

	int extensionStart = thirdSlash + caseName.length() + 1;

	int ctFileNameStart = thirdSlash;
	int ctFileNameEnd   = grayscaleEntry.find_last_of('.');
	ctFileName = grayscaleEntry.substr( ctFileNameStart + 1, ctFileNameEnd - ctFileNameStart - 1);

        std::stringstream tmpStream1;
        tmpStream1 << "/var/tmp/" << study << "/";
        studyTmpDir = tmpStream1.str();

        std::stringstream tmpStream2;
        tmpStream2 << studyTmpDir << patientID << "/";
        patientTmpDir = tmpStream2.str();

        std::stringstream tmpStream3;
        tmpStream3 << patientTmpDir << caseName << "/";
        caseTmpDir = tmpStream3.str();
      
        std::stringstream stream1;
        stream1 << ctFileName << ".nrrd";
        ctFileNameHeader = stream1.str();

        std::stringstream stream3;
        stream3 << "/var/tmp/" << study << "/" << patientID << "/" << caseName << "/" << ctFileNameHeader;
        ctTmpDirAndFileNameHeader = stream3.str();

        if (inLabelMapEntry.compare("NA") == 0)
          {
          inLabelMapFileNameHeader          = "NA";
          inLabelMapTmpDirAndFileNameHeader = "NA";
          }
        else
          {
          int extensionStop = inLabelMapEntry.find( '.', 0 ); 

          std::string inLabelMapExtension = inLabelMapEntry.substr( extensionStart, extensionStop - extensionStart);

          std::stringstream stream4;
          stream4 << caseName << inLabelMapExtension << ".nrrd";
          inLabelMapFileNameHeader = stream4.str();

          std::stringstream stream6;
          stream6 << "/var/tmp/" << study << "/" << patientID << "/" << caseName << "/" << inLabelMapFileNameHeader;
          inLabelMapTmpDirAndFileNameHeader = stream6.str();
        }

        if (outLabelMapEntry.compare("NA") == 0)
          {
          outLabelMapFileNameHeader          = "NA";
          outLabelMapTmpDirAndFileNameHeader = "NA";
          }
        else
          {
          int extensionStop = outLabelMapEntry.find( '.', 0 ); 

          std::string outLabelMapExtension = outLabelMapEntry.substr( extensionStart, extensionStop - extensionStart);

          std::stringstream stream4;
          stream4 << caseName << outLabelMapExtension << ".nrrd";
          outLabelMapFileNameHeader = stream4.str();

          std::stringstream stream6;
          stream6 << "/var/tmp/" << study << "/" << patientID << "/" << caseName << "/" << outLabelMapFileNameHeader;
          outLabelMapTmpDirAndFileNameHeader = stream6.str();
          }

        if (regionTypeIndicesEntry.compare("NA") == 0)
          {
          regionTypeIndicesFileName          = "NA";
          regionTypeIndicesTmpDirAndFileName = "NA";
          }
        else
          {
          int extensionStop = regionTypeIndicesEntry.find( '.', 0 ); 

          std::string regionTypeIndicesExtension = regionTypeIndicesEntry.substr( extensionStart, extensionStop - extensionStart);

          std::stringstream stream4;
          stream4 << caseName << regionTypeIndicesExtension << ".csv";
          regionTypeIndicesFileName = stream4.str();

          std::stringstream stream6;
          stream6 << "/var/tmp/" << study << "/" << patientID << "/" << caseName << "/" << regionTypeIndicesFileName;
          regionTypeIndicesTmpDirAndFileName = stream6.str();
          }

        // Now that we have all the component strings, we can set up the
        // files for the session. Only add to session file data if the
        // output mask and region-type indices file name do not already
        // exist. 
        if ((inLabelMapFileNameHeader.compare("NA") == 0 || DoesRemoteFileExist(study, patientID, caseName, inLabelMapFileNameHeader)) &&
            (outLabelMapFileNameHeader.compare("NA") == 0 || !DoesRemoteFileExist(study, patientID, caseName, outLabelMapFileNameHeader)) &&
            (regionTypeIndicesFileName.compare("NA") == 0 || !DoesRemoteFileExist(study, patientID, caseName, regionTypeIndicesFileName)))
          {
          // If we're in here, it means we've identified a case that
          // needs processing, so store
          SESSIONDATA data;
          data.patientID = patientID;
          data.study = study;
          data.ctFileName = ctFileName;
          data.caseName = caseName;
          data.ctFileName = ctFileName;
          data.ctFileNameHeader = ctFileNameHeader;
          data.ctTmpDirAndFileNameHeader = ctTmpDirAndFileNameHeader;
          data.inLabelMapFileNameHeader = inLabelMapFileNameHeader;
          data.inLabelMapTmpDirAndFileNameHeader = inLabelMapTmpDirAndFileNameHeader;
          data.outLabelMapFileNameHeader = outLabelMapFileNameHeader;
          data.outLabelMapTmpDirAndFileNameHeader = outLabelMapTmpDirAndFileNameHeader;
          data.regionTypeIndicesFileName = regionTypeIndicesFileName;
          data.regionTypeIndicesTmpDirAndFileName = regionTypeIndicesTmpDirAndFileName;
          data.studyTmpDir = studyTmpDir;
          data.patientTmpDir = patientTmpDir;
          data.caseTmpDir = caseTmpDir;
          
          sessionDataVec.push_back( data );
          }     
        }    
      } 
    }
  
  if ( sessionDataVec.size() > 0 )
    {    
    CopySessionDataFromMAD( sessionDataVec[0] );

    std::cout << "Reading grayscale image..." << std::endl;
    std::cout << sessionDataVec[0].ctFileNameHeader << std::endl;
    GrayscaleReaderType::Pointer grayReader = GrayscaleReaderType::New();
      grayReader->SetFileName( sessionDataVec[0].ctTmpDirAndFileNameHeader );
    try
      {
      grayReader->Update();
      }
    catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught reading grayscale image:";
      std::cerr << excp << std::endl;
      }
          
    std::cout << "DONE." << std::endl;    
    grayscaleImageRead = true;    

    assistantInstance->SetGrayscaleImage( grayReader->GetOutput() );	

    LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
    LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
    LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();

    // Label the main window to indicate which image has been read    
    acilAssistantMainWindow->label( sessionDataVec[0].caseName.c_str() );

    // Initialize the label maps
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    // Read in the label map if necessary
    if ( sessionDataVec[0].inLabelMapFileNameHeader.compare("NA") != 0 )
      {
      std::cout << "Reading label map image..." << std::endl;
      LabelMapReaderType::Pointer labelReader = LabelMapReaderType::New();
        labelReader->SetFileName( sessionDataVec[0].inLabelMapTmpDirAndFileNameHeader );
      try
        {
        labelReader->Update();
        }
      catch ( itk::ExceptionObject &excp )
        {
        std::cerr << "Exception caught reading label map file:";
        std::cerr << excp << std::endl;
        }

      std::cout << "DONE." << std::endl;	
      labelMapImageRead = true;
            
      assistantInstance->SetLabelMapImage( labelReader->GetOutput() );
      }
    
    int numberOfSlices = grayReader->GetOutput()->GetBufferedRegion().GetSize()[2];
    
    sliceSlider->maximum( numberOfSlices-1 );        	
    
    InitializeViewer();                
    }
  else
    {
    std::cout << "Session has been completed or session file is empty." << std::endl;
    }
}


void opacitySlider_CB( Fl_Widget*, void* ) {
  UpdateViewer();
}

void paintBrushAndEraserMenu_CB( Fl_Widget*, void* ) {
  regionGrowingInput->regionGrowingWindow->hide();
  paintBrushAndEraserInput->paintBrushAndEraserWindow->show();
  queryOverlayInput->queryOverlayWindow->hide();
}

void queryOverlayMenu_CB( Fl_Widget*, void* ) {
  regionGrowingInput->regionGrowingWindow->hide();
  paintBrushAndEraserInput->paintBrushAndEraserWindow->hide();
  queryOverlayInput->queryOverlayWindow->show();
}

void leftLungRightLungMenu_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cout << "Must first read a grayscale image!" << std::endl;
  
  return;
}

if ( !labelMapImageRead )
{
  std::cout << "Must first read a label map image!" << std::endl;
  
  return;
}

std::cout << "Segmenting left lung and right lung..." << std::endl;
if ( !assistantInstance->LabelLeftLungRightLung() )
{
  std::cout << "Error segmenting left lung and right lung." << std::endl;
  
  return;
}

std::cout << "DONE." << std::endl;

UpdateViewer();
}

void paletteCounter_CB( Fl_Widget*, void* ) 
{
  paletteCounter->paletteCounterWindow->show();
}

void lungMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cout << "Must first read a grayscale image!" << std::endl;  
    return;
    }
  
  sliceViewer->iwMax( -100 );
  sliceViewer->iwMin( -1200 );

  UpdateViewer();
}

void muscleMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cout << "Must first read a grayscale image!" << std::endl;  
    return;
    }

  sliceViewer->iwMax( 90 );
  sliceViewer->iwMin( -50 );
  
  UpdateViewer();
}


void regionGrowingMenu_CB( Fl_Widget*, void* ) 
{
  paintBrushAndEraserInput->paintBrushAndEraserWindow->hide();
  queryOverlayInput->queryOverlayWindow->hide();
  regionGrowingInput->regionGrowingWindow->show();
}

void lungLobesMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
      std::cout << "Must first read a grayscale image!" << std::endl;
  
      return;
    }

  if ( !labelMapImageRead )
    {
      std::cout << "Must first read a label map image!" << std::endl;
      
      return;
    }

  std::cout << "Segmenting lung lobes..." << std::endl;
  if ( !assistantInstance->SegmentLungLobes() )
    {
      std::cout << "Fissures have not been properly identified." << std::endl;
  
      return;
    }

  std::cout << "DONE." << std::endl;

  UpdateViewer();
}

void Quit_CB( Fl_Widget*, void* ) {
  exit(0);
}

void clickSelect_CB( float x, float y, float z, float value ) 
{
  cip::ChestConventions conventions;

  ACILAssistantBase::GrayscaleImageType::IndexType index;

  index[0] = static_cast< unsigned int >( x );
  index[1] = static_cast< unsigned int >( y );
  index[2] = static_cast< unsigned int >( z );

  if ( grayscaleImageRead )
    { 
      if ( Fl::event_state(FL_META) && regionGrowingInput->regionGrowingWindow->visible() )
	{
	  assistantInstance->UndoSegmentation();
	}
      if ( Fl::event_state(FL_SHIFT) )
	{
	  if ( regionGrowingInput->regionGrowingWindow->visible() )
	    {
	      short minThreshold = regionGrowingInput->GetMinThreshold();
	      short maxThreshold = regionGrowingInput->GetMaxThreshold();
	      unsigned int radius = regionGrowingInput->GetROIRadius();
	      unsigned char cipRegion = regionGrowingInput->GetChestRegion();
	      unsigned char cipType = regionGrowingInput->GetChestType();

	      assistantInstance->ConnectedThreshold( index, minThreshold, maxThreshold, radius, cipRegion, cipType );
	    }
	}

      if ( paintBrushAndEraserInput->paintBrushAndEraserWindow->visible() )
	{
	  unsigned int  radius           = paintBrushAndEraserInput->GetToolRadius();
	  unsigned char cipType          = paintBrushAndEraserInput->GetChestType(); 	
	  unsigned char cipRegion        = paintBrushAndEraserInput->GetChestRegion(); 	
	  short         lowerThreshold   = paintBrushAndEraserInput->GetToolLowerThreshold();
	  short         upperThreshold   = paintBrushAndEraserInput->GetToolUpperThreshold();

	  unsigned int orientation = sliceViewer->orientation();
	  
	  if ( paintBrushAndEraserInput->GetPaintBrushSelected() )
	    {  
	      assistantInstance->PaintLabelMapSlice( index, cipType, cipRegion, radius, lowerThreshold, upperThreshold, orientation ); 
	    }
	  else if ( paintBrushAndEraserInput->GetEraserSelected() )
	    {  
	      assistantInstance->EraseLabelMapSlice( index, cipRegion, cipType, radius, lowerThreshold, upperThreshold, 
						     paintBrushAndEraserInput->GetEraseSelectedSelected(), orientation );
	    }
	}

      // Update the palette counter
      if ( paletteCounter->paletteCounterWindow->visible() )
	{
	  unsigned char cipType   = paintBrushAndEraserInput->GetChestType(); 	
	  unsigned char cipRegion = paintBrushAndEraserInput->GetChestRegion(); 	
	  paletteCounter->SetChestRegion( conventions.GetChestRegionName(cipRegion) );
	  paletteCounter->SetChestType( conventions.GetChestTypeName(cipType) );
	  paletteCounter->SetCount( assistantInstance->GetNumberOfPaintedIndices( cipRegion, cipType ) );
	}

      if ( queryOverlayInput->queryOverlayWindow->visible() )
	{
	  unsigned short label = assistantInstance->GetLabelMapImage()->GetPixel( index );
	  queryOverlayInput->SetChestRegion( conventions.GetChestRegionNameFromValue( label ) );
	  queryOverlayInput->SetChestType( conventions.GetChestTypeNameFromValue( label ) );
	}

      UpdateViewer();
    }
}

void SaveLabelMapImageMenu_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cerr << "No label map image to save!" << std::endl;
  
  return;
}


Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::CREATE, "Open");	                
    chooser.show();
 
  typedef itk::Image< unsigned short, 3 >       LabelMapType;
  typedef itk::ImageFileWriter< LabelMapType >  WriterType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Writing label map image..." << std::endl;
    WriterType::Pointer writer = WriterType::New();
      writer->SetFileName( chooser.value() );
      writer->SetInput( assistantInstance->GetLabelMapImage() );
      writer->UseCompressionOn();
      try
      {
      writer->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught writer label map image:";
      std::cerr << excp << std::endl;
      }
        
    std::cout << "DONE." << std::endl;
    }
}

void SaveSessionDataMenu_CB( Fl_Widget*, void* ) 
{
  typedef itk::Image< unsigned short, 3 >             LabelMapType;
  typedef itk::ImageFileWriter< LabelMapType >        WriterType; 
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
  typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType;
  typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType;
  
  if ( !grayscaleImageRead )
    {
    std::cerr << "Nothing to save!" << std::endl;
    
    return;
    }
  
  if ( sessionDataVec[0].outLabelMapTmpDirAndFileNameHeader.compare( "NA" ) != 0 )
    {
    std::cout << "Writing label map image..." << std::endl;
    WriterType::Pointer writer = WriterType::New();
      writer->SetFileName( sessionDataVec[0].outLabelMapTmpDirAndFileNameHeader );
      writer->SetInput( assistantInstance->GetLabelMapImage() );
      writer->UseCompressionOn();
    try
      {
      writer->Update();
      }
    catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught writer label map image:";
      std::cerr << excp << std::endl;
      }
    
    std::cout << "DONE." << std::endl;
    }
     
  // Write the region and type indices to file       
  if ( sessionDataVec[0].regionTypeIndicesTmpDirAndFileName.compare( "NA" ) != 0 )
    {
    std::cout << "Writing region and type indices..." << std::endl;
    assistantInstance->WritePaintedRegionTypePoints( sessionDataVec[0].regionTypeIndicesTmpDirAndFileName );
    std::cout << "DONE." << std::endl;
    }

  // Now copy the data to MAD 
  CopySessionDataToMAD( sessionDataVec[0] );

  // Now that the label map has been saved, we want to load the group
  // of images for the next session block. First eliminate the file names
  // of the session block that was just processed
  sessionDataVec.erase( sessionDataVec.begin() );

  // Make sure the memory allocated for the images of the current session
  // block has been freed. Calling this method will also clear the stored
  // type indices that were recorded during painting
  assistantInstance->Clear();

  if ( sessionDataVec.size() > 0 )
    {
    CopySessionDataFromMAD( sessionDataVec[0] );

    // Read the grayscale image
    std::cout << "Reading grayscale image..." << std::endl;
    std::cout << sessionDataVec[0].ctFileNameHeader << std::endl;
    GrayscaleReaderType::Pointer grayscaleReader = GrayscaleReaderType::New();
      grayscaleReader->SetFileName( sessionDataVec[0].ctTmpDirAndFileNameHeader );
    try
      {
      grayscaleReader->Update();
      }
    catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught reading grayscale image:";
      std::cerr << excp << std::endl;
      }

    int numberOfSlices = grayscaleReader->GetOutput()->GetBufferedRegion().GetSize()[2];

    sliceSlider->maximum( numberOfSlices-1 );

    assistantInstance->SetGrayscaleImage( grayscaleReader->GetOutput() );
    
    std::cout << "DONE." << std::endl;  	
    
    LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
    LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
    LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();
    
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    // Label the main window to indicate which image has been read
    acilAssistantMainWindow->label( sessionDataVec[0].caseName.c_str() );

    // Read the label map image
    if ( (sessionDataVec[0].inLabelMapTmpDirAndFileNameHeader).compare( "NA" ) != 0 )
      {
      std::cout << "Reading label map image..." << std::endl;
      std::cout << sessionDataVec[0].inLabelMapFileNameHeader << std::endl;
      LabelMapReaderType::Pointer labelMapReader = LabelMapReaderType::New();
        labelMapReader->SetFileName( sessionDataVec[0].inLabelMapTmpDirAndFileNameHeader );
      try
        {
        labelMapReader->Update();
        }
      catch ( itk::ExceptionObject &excp )
        {
        std::cerr << "Exception caught reading label map image:";
        std::cerr << excp << std::endl;
        }

      assistantInstance->SetLabelMapImage( labelMapReader->GetOutput() );
      
      std::cout << "DONE." << std::endl;
      }
    
    // Update the slice viewer with the new images
    sliceViewer->clear();
    InitializeViewer();

    // Make sure the paint brush points to the correct image
    paintBrushAndEraserInput->SetLabelMapImage( assistantInstance->GetLabelMapImage() );
    }
  else
    {
    std::cout << "Session complete." << std::endl;
    }
}

void SaveRegionTypePointsMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cerr << "No region-type indices to save!" << std::endl;
    
    return;
    }


  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::CREATE, "Open");	                
  chooser.show();
 
  //
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }
  
  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Writing region-type indices..." << std::endl;
    assistantInstance->WritePaintedRegionTypePoints( chooser.value() );
    std::cout << "DONE." << std::endl;
    }
}


std::string exec(const char* cmd) 
{
  FILE* pipe = popen(cmd, "r");
  if (!pipe) return "ERROR";
  char buffer[128];
  std::string result = "";
  while(!feof(pipe)) 
    {
    if(fgets(buffer, 128, pipe) != NULL)
      result += buffer;
    }
  pclose(pipe);

  return result;
}

bool DoesRemoteFileExist(std::string study, std::string patientID, std::string caseName, std::string fileName)
{
  std::stringstream stream;
  stream << "ssh copd@mad-replicated1.research.partners.org ls /mad/store-replicated/clients/copd/Processed/" << study << "/" << patientID << "/" << caseName << "/" << fileName;
  std::string command = stream.str(); 

  std::string status = exec(command.c_str());

  if (status.length() > 0)
    {
    return true;
    }

  return false;
}

void CopySessionDataFromMAD( SESSIONDATA data )
{
  std::stringstream mkDirStream1;
  mkDirStream1 << "mkdir " << data.studyTmpDir;
  std::string mkStudyTmpDir = mkDirStream1.str();
  system( mkStudyTmpDir.c_str() );

  std::stringstream mkDirStream2;
  mkDirStream2 << "mkdir " << data.patientTmpDir;
  std::string mkPatientTmpDir = mkDirStream2.str();
  system( mkPatientTmpDir.c_str() );

  std::stringstream mkDirStream3;
  mkDirStream3 << "mkdir " << data.caseTmpDir;
  std::string mkCaseTmpDir = mkDirStream3.str();
  system( mkCaseTmpDir.c_str() );

  // Now copy over the CT data
  std::stringstream permissionHeaderStream;
  permissionHeaderStream << "ssh copd@mad-replicated1.research.partners.org 'chmod 744 /mad/store-replicated/clients/copd/" << 
    data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.ctFileName << ".nrrd'";
  std::string permissionCTheader = permissionHeaderStream.str();
  system( permissionCTheader.c_str() );

  std::stringstream headerStream;
  headerStream << "scp copd@mad-replicated1.research.partners.org:Processed/" << data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.ctFileName << ".nrrd " << data.caseTmpDir;
  std::string cpCTheader = headerStream.str();
  system( cpCTheader.c_str() );

  // Copy over the input label map if necessary
  if (data.inLabelMapFileNameHeader.compare("NA") != 0)
    {
      std::stringstream permissionHeaderStream2;
      permissionHeaderStream2 << "ssh copd@mad-replicated1.research.partners.org 'chmod 744 /mad/store-replicated/clients/copd/" << 
	data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.inLabelMapFileNameHeader << "'";
      std::string permissionCTheader2 = permissionHeaderStream2.str();
      system( permissionCTheader2.c_str() );

      std::stringstream headerStream2;
      headerStream2 << "scp copd@mad-replicated1.research.partners.org:Processed/" << data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.inLabelMapFileNameHeader << " " << data.caseTmpDir;
      std::string permissionInLabelMapHeader = headerStream2.str();
      system( permissionInLabelMapHeader.c_str() );      
    }
}

void CopySessionDataToMAD( SESSIONDATA data )
{
  // Copy over the input label map if necessary, and then delete
  if (data.outLabelMapFileNameHeader.compare("NA") != 0)
    {
      std::stringstream permissionHeaderStream;
      permissionHeaderStream << "ssh copd@mad-replicated1.research.partners.org 'chmod 744 /mad/store-replicated/clients/copd/" << 
	data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.outLabelMapFileNameHeader << "'";
      std::string permissionHeader = permissionHeaderStream.str();
      system( permissionHeader.c_str() );

      std::stringstream headerStream;
      headerStream << "scp " << data.outLabelMapTmpDirAndFileNameHeader << " copd@mad-replicated1.research.partners.org:Processed/" << data.study << "/" << data.patientID << "/" << data.caseName << "/";
      std::string cpOutLabelMapHeader = headerStream.str();
      system( cpOutLabelMapHeader.c_str() );
      
      // Now delete
      std::stringstream deleteHeaderStream;
      deleteHeaderStream << "rm " << data.outLabelMapTmpDirAndFileNameHeader;
      std::string deleteHeader = deleteHeaderStream.str();
      system( deleteHeader.c_str() );      
    }

  // Copy over the region and type points if necessary, and then delete
  if (data.regionTypeIndicesFileName.compare("NA") != 0)
    {
      std::stringstream permissionStream;
      permissionStream << "ssh copd@mad-replicated1.research.partners.org 'chmod 744 /mad/store-replicated/clients/copd/" << 
	data.study << "/" << data.patientID << "/" << data.caseName << "/" << data.regionTypeIndicesFileName << "'";
      std::string permission = permissionStream.str();
      system( permission.c_str() );

      std::stringstream stream;
      stream << "scp " << data.regionTypeIndicesTmpDirAndFileName << " copd@mad-replicated1.research.partners.org:Processed/" << data.study << "/" << data.patientID << "/" << data.caseName << "/";
      std::string cpRegionTypeIndices = stream.str();
      system( cpRegionTypeIndices.c_str() );
      
      // Now delete
      std::stringstream deleteIndicesStream;
      deleteIndicesStream << "rm " << data.regionTypeIndicesTmpDirAndFileName;
      std::string deleteIndices = deleteIndicesStream.str();
      system( deleteIndices.c_str() );
    }
  
  // Delete the CT data that was copied over
  std::stringstream deleteHeaderStream;
  deleteHeaderStream << "rm " << data.ctTmpDirAndFileNameHeader;
  std::string deleteHeader = deleteHeaderStream.str();
  system( deleteHeader.c_str() );
  
  // Delete the input label map if necessary
  if ( data.inLabelMapFileNameHeader.compare("NA") != 0 )
    {
    std::stringstream deleteHeaderStream2;
    deleteHeaderStream2 << "rm " << data.inLabelMapTmpDirAndFileNameHeader;
    std::string deleteHeader2 = deleteHeaderStream2.str();
    system( deleteHeader2.c_str() );  
    }
}



//-------------------------------------------------
// void SessionFile_CB( Fl_Widget*, void* ) {
//   typedef itk::Image< short, 3 >                      GrayscaleImageType;
//   typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType; 
//   typedef itk::Image< unsigned short, 3 >             LabelMapType;
//   typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType; 

//   Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
//   chooser.show();
 
//   // Block until user picks something
//   while(chooser.shown())
//     {
//     Fl::wait(); 
//     }

//   if ( chooser.value() == NULL )
//     {   
//     return; 
//     }
//   else
//     {
//     char firstLine[512];
//     char secondLine[512];
//     char thirdLine[512];
//     char fourthLine[512];
    
//     std::cout << "Reading session file..." << std::endl;
    
//     std::ifstream sessionFile( chooser.value() );
//     while ( !sessionFile.eof() )
//       {
//       sessionFile.getline( firstLine, 512 );
//       std::string grayscaleFileName( firstLine );   
      
//       sessionFile.getline( secondLine, 512 ); 
//       std::string inLabelMapFileName( secondLine );        
      
//       sessionFile.getline( thirdLine, 512 );
//       std::string outLabelMapFileName( thirdLine );   
      
//       sessionFile.getline( fourthLine, 512 );  
//       std::string regionTypeIndicesFileName( fourthLine );   
        
//       struct stat stFileInfo;             

//       // Only add to session file data if the output mask and
//       // region-type indices file name do not already exist
//       if ( stat( firstLine, &stFileInfo ) == 0 &&
//            (stat( secondLine, &stFileInfo) == 0  || inLabelMapFileName.compare("NA") == 0) &&
//            (stat( thirdLine, &stFileInfo ) != 0  || outLabelMapFileName.compare("NA") == 0) &&
//            (stat( fourthLine, &stFileInfo ) != 0 || regionTypeIndicesFileName.compare("NA") == 0))
//         {          
//         sessionGrayscaleFileNameVec.push_back( grayscaleFileName );              
//         sessionInLabelMapFileNameVec.push_back( inLabelMapFileName );                  
//         sessionOutLabelMapFileNameVec.push_back( outLabelMapFileName );  
//         sessionRegionTypeIndicesFileNameVec.push_back( regionTypeIndicesFileName );
//         }
//       }    
//     }
    
//   if ( sessionGrayscaleFileNameVec.size() > 0 )
//     {    
//     std::cout << "Reading grayscale image..." << std::endl;
//     std::cout << sessionGrayscaleFileNameVec[0] << std::endl;
//     GrayscaleReaderType::Pointer grayReader = GrayscaleReaderType::New();
//       grayReader->SetFileName( sessionGrayscaleFileNameVec[0] );
//     try
//       {
//       grayReader->Update();
//       }
//     catch ( itk::ExceptionObject &excp )
//       {
//       std::cerr << "Exception caught reading grayscale image:";
//       std::cerr << excp << std::endl;
//       }
          
//     std::cout << "DONE." << std::endl;    
//     grayscaleImageRead = true;    

//     assistantInstance->SetGrayscaleImage( grayReader->GetOutput() );	

//     LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
//     LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
//     LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();

//     // Label the main window to indicate which image has been read
//     unsigned int slashLoc = -1;
    
//     do
//       {
//       slashLoc = sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 );
//       }
//     while ( sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 ) != std::string::npos );
    
//     acilAssistantMainWindow->label( sessionGrayscaleFileNameVec[0].substr( slashLoc+1, sessionGrayscaleFileNameVec[0].size()-slashLoc-1 ).c_str() );

//     // Initialize the label maps
//     assistantInstance->InitializeLabelMapImage( size, spacing, origin );

//     // Read in the label map if necessary
//     if ( (sessionInLabelMapFileNameVec[0]).compare("NA") != 0 )
//       {
//       std::cout << "Reading label map image..." << std::endl;
//       LabelMapReaderType::Pointer labelReader = LabelMapReaderType::New();
//         labelReader->SetFileName( sessionInLabelMapFileNameVec[0] );
//       try
//         {
//         labelReader->Update();
//         }
//       catch ( itk::ExceptionObject &excp )
//         {
//         std::cerr << "Exception caught reading label map file:";
//         std::cerr << excp << std::endl;
//         }

//       std::cout << "DONE." << std::endl;	
//       labelMapImageRead = true;
            
//       assistantInstance->SetLabelMapImage( labelReader->GetOutput() );
//       }
    
//     int numberOfSlices = grayReader->GetOutput()->GetBufferedRegion().GetSize()[2];
    
//     sliceSlider->maximum( numberOfSlices-1 );        	
    
//     InitializeViewer();                
//     }
//   else
//     {
//     std::cout << "Session has been completed or session file is empty." << std::endl;
//     }
// }



// void SaveSessionDataMenu_CB( Fl_Widget*, void* ) 
// {
//   typedef itk::Image< unsigned short, 3 >             LabelMapType;
//   typedef itk::ImageFileWriter< LabelMapType >        WriterType; 
//   typedef itk::Image< short, 3 >                      GrayscaleImageType;
//   typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType;
//   typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType;

//   if ( !grayscaleImageRead )
//     {
//     std::cerr << "Nothing to save!" << std::endl;
    
//     return;
//     }

//   if ( (sessionOutLabelMapFileNameVec[0]).compare( "NA" ) != 0 )
//     {
//     std::cout << "Writing label map image..." << std::endl;
//     WriterType::Pointer writer = WriterType::New();
//       writer->SetFileName( sessionOutLabelMapFileNameVec[0] );
//       writer->SetInput( assistantInstance->GetLabelMapImage() );
//       writer->UseCompressionOn();
//     try
//       {
//       writer->Update();
//       }
//     catch ( itk::ExceptionObject &excp )
//       {
//       std::cerr << "Exception caught writer label map image:";
//       std::cerr << excp << std::endl;
//       }
        
//     std::cout << "DONE." << std::endl;
//     }
  
//   // Write the region and type indices to file
//   if ( (sessionRegionTypeIndicesFileNameVec[0]).compare( "NA" ) != 0 )
//     {
//     std::cout << "Writing region and type indices..." << std::endl;
//     assistantInstance->WritePaintedRegionTypePoints( sessionRegionTypeIndicesFileNameVec[0] );
//     std::cout << "DONE." << std::endl;
//     }

//   // Now that the label map has been saved, we want to load the group
//   // of images for the next session block. First eliminate the file names
//   // of the session block that was just processed
//   sessionGrayscaleFileNameVec.erase( sessionGrayscaleFileNameVec.begin() );              
//   sessionInLabelMapFileNameVec.erase( sessionInLabelMapFileNameVec.begin() );
//   sessionOutLabelMapFileNameVec.erase( sessionOutLabelMapFileNameVec.begin() );
//   sessionRegionTypeIndicesFileNameVec.erase( sessionRegionTypeIndicesFileNameVec.begin() );

//   // Make sure the memory allocated for the images of the current session
//   // block has been freed. Calling this method will also clear the stored
//   // type indices that were recorded during painting
//   assistantInstance->Clear();

//   if ( sessionGrayscaleFileNameVec.size() > 0 )
//     {
//     // Read the grayscale image
//     std::cout << "Reading grayscale image..." << std::endl;
//     std::cout << sessionGrayscaleFileNameVec[0] << std::endl;
//     GrayscaleReaderType::Pointer grayscaleReader = GrayscaleReaderType::New();
//       grayscaleReader->SetFileName( sessionGrayscaleFileNameVec[0] );
//     try
//       {
//       grayscaleReader->Update();
//       }
//     catch ( itk::ExceptionObject &excp )
//       {
//       std::cerr << "Exception caught reading grayscale image:";
//       std::cerr << excp << std::endl;
//       }

//     int numberOfSlices = grayscaleReader->GetOutput()->GetBufferedRegion().GetSize()[2];

//     sliceSlider->maximum( numberOfSlices-1 );

//     assistantInstance->SetGrayscaleImage( grayscaleReader->GetOutput() );
    
//     std::cout << "DONE." << std::endl;  	
    
//     LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
//     LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
//     LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();

//     assistantInstance->InitializeLabelMapImage( size, spacing, origin );

//     // Label the main window to indicate which image has been read
//     unsigned int slashLoc = -1;
    
//     do
//       {
//       slashLoc = sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 );
//       }
//     while ( sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 ) != std::string::npos );
    
//     acilAssistantMainWindow->label( sessionGrayscaleFileNameVec[0].substr( slashLoc+1, sessionGrayscaleFileNameVec[0].size()-slashLoc-1 ).c_str() );

//     // Read the label map image
//     if ( (sessionInLabelMapFileNameVec[0]).compare( "NA" ) != 0 )
//       {
//       std::cout << "Reading label map image..." << std::endl;
//       std::cout << sessionInLabelMapFileNameVec[0] << std::endl;
//       LabelMapReaderType::Pointer labelMapReader = LabelMapReaderType::New();
//         labelMapReader->SetFileName( sessionInLabelMapFileNameVec[0] );
//       try
//         {
//         labelMapReader->Update();
//         }
//       catch ( itk::ExceptionObject &excp )
//         {
//         std::cerr << "Exception caught reading label map image:";
//         std::cerr << excp << std::endl;
//         }

//       assistantInstance->SetLabelMapImage( labelMapReader->GetOutput() );
      
//       std::cout << "DONE." << std::endl;
//       }
    
//     // Update the slice viewer with the new images
//     sliceViewer->clear();
//     InitializeViewer();

//     // Make sure the paint brush points to the correct image
//     paintBrushAndEraserInput->SetLabelMapImage( assistantInstance->GetLabelMapImage() );
//     }
//   else
//     {
//     std::cout << "Session complete." << std::endl;
//     }
// }
